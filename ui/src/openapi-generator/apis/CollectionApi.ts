/* tslint:disable */
/* eslint-disable */
/**
 * Enduro API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BatchResult,
  BulkRequestBody,
  BulkStatusResult,
  CollectionDecideRequest,
  CollectionNotfound,
  EnduroCollectionWorkflowStatus,
  EnduroMonitorUpdate,
  EnduroStoredCollection,
  ListResponseBody,
} from '../models';
import {
    BatchResultFromJSON,
    BatchResultToJSON,
    BulkRequestBodyFromJSON,
    BulkRequestBodyToJSON,
    BulkStatusResultFromJSON,
    BulkStatusResultToJSON,
    CollectionDecideRequestFromJSON,
    CollectionDecideRequestToJSON,
    CollectionNotfoundFromJSON,
    CollectionNotfoundToJSON,
    EnduroCollectionWorkflowStatusFromJSON,
    EnduroCollectionWorkflowStatusToJSON,
    EnduroMonitorUpdateFromJSON,
    EnduroMonitorUpdateToJSON,
    EnduroStoredCollectionFromJSON,
    EnduroStoredCollectionToJSON,
    ListResponseBodyFromJSON,
    ListResponseBodyToJSON,
} from '../models';

export interface CollectionBulkRequest {
    bulkRequestBody: BulkRequestBody;
}

export interface CollectionCancelRequest {
    id: number;
}

export interface CollectionDecideOperationRequest {
    id: number;
    collectionDecideRequest: CollectionDecideRequest;
}

export interface CollectionDeleteRequest {
    id: number;
}

export interface CollectionDownloadRequest {
    id: number;
}

export interface CollectionListRequest {
    name?: string;
    originalId?: string;
    transferId?: string;
    aipId?: string;
    pipelineId?: string;
    earliestCreatedTime?: Date;
    latestCreatedTime?: Date;
    status?: CollectionListStatusEnum;
    cursor?: string;
}

export interface CollectionRetryRequest {
    id: number;
}

export interface CollectionShowRequest {
    id: number;
}

export interface CollectionWorkflowRequest {
    id: number;
}

/**
 * CollectionApi - interface
 * 
 * @export
 * @interface CollectionApiInterface
 */
export interface CollectionApiInterface {
    /**
     * Bulk operations (retry, cancel...).
     * @summary bulk collection
     * @param {BulkRequestBody} bulkRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApiInterface
     */
    collectionBulkRaw(requestParameters: CollectionBulkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BatchResult>>;

    /**
     * Bulk operations (retry, cancel...).
     * bulk collection
     */
    collectionBulk(requestParameters: CollectionBulkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchResult>;

    /**
     * Retrieve status of current bulk operation.
     * @summary bulk_status collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApiInterface
     */
    collectionBulkStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BulkStatusResult>>;

    /**
     * Retrieve status of current bulk operation.
     * bulk_status collection
     */
    collectionBulkStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BulkStatusResult>;

    /**
     * Cancel collection processing by ID
     * @summary cancel collection
     * @param {number} id Identifier of collection to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApiInterface
     */
    collectionCancelRaw(requestParameters: CollectionCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Cancel collection processing by ID
     * cancel collection
     */
    collectionCancel(requestParameters: CollectionCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Make decision for a pending collection by ID
     * @summary decide collection
     * @param {number} id Identifier of collection to look up
     * @param {CollectionDecideRequest} collectionDecideRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApiInterface
     */
    collectionDecideRaw(requestParameters: CollectionDecideOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Make decision for a pending collection by ID
     * decide collection
     */
    collectionDecide(requestParameters: CollectionDecideOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Delete collection by ID
     * @summary delete collection
     * @param {number} id Identifier of collection to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApiInterface
     */
    collectionDeleteRaw(requestParameters: CollectionDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete collection by ID
     * delete collection
     */
    collectionDelete(requestParameters: CollectionDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Download collection by ID
     * @summary download collection
     * @param {number} id Identifier of collection to look up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApiInterface
     */
    collectionDownloadRaw(requestParameters: CollectionDownloadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>>;

    /**
     * Download collection by ID
     * download collection
     */
    collectionDownload(requestParameters: CollectionDownloadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob>;

    /**
     * List all stored collections
     * @summary list collection
     * @param {string} [name] 
     * @param {string} [originalId] 
     * @param {string} [transferId] Identifier of Archivematica tranfser
     * @param {string} [aipId] Identifier of Archivematica AIP
     * @param {string} [pipelineId] Identifier of Archivematica pipeline
     * @param {Date} [earliestCreatedTime] 
     * @param {Date} [latestCreatedTime] 
     * @param {'new' | 'in progress' | 'done' | 'error' | 'unknown' | 'queued' | 'pending' | 'abandoned'} [status] 
     * @param {string} [cursor] Pagination cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApiInterface
     */
    collectionListRaw(requestParameters: CollectionListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListResponseBody>>;

    /**
     * List all stored collections
     * list collection
     */
    collectionList(requestParameters: CollectionListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListResponseBody>;

    /**
     * 
     * @summary monitor collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApiInterface
     */
    collectionMonitorRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * monitor collection
     */
    collectionMonitor(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Retry collection processing by ID
     * @summary retry collection
     * @param {number} id Identifier of collection to retry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApiInterface
     */
    collectionRetryRaw(requestParameters: CollectionRetryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Retry collection processing by ID
     * retry collection
     */
    collectionRetry(requestParameters: CollectionRetryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Show collection by ID
     * @summary show collection
     * @param {number} id Identifier of collection to show
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApiInterface
     */
    collectionShowRaw(requestParameters: CollectionShowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnduroStoredCollection>>;

    /**
     * Show collection by ID
     * show collection
     */
    collectionShow(requestParameters: CollectionShowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnduroStoredCollection>;

    /**
     * Retrieve workflow status by ID
     * @summary workflow collection
     * @param {number} id Identifier of collection to look up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApiInterface
     */
    collectionWorkflowRaw(requestParameters: CollectionWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnduroCollectionWorkflowStatus>>;

    /**
     * Retrieve workflow status by ID
     * workflow collection
     */
    collectionWorkflow(requestParameters: CollectionWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnduroCollectionWorkflowStatus>;

}

/**
 * 
 */
export class CollectionApi extends runtime.BaseAPI implements CollectionApiInterface {

    /**
     * Bulk operations (retry, cancel...).
     * bulk collection
     */
    async collectionBulkRaw(requestParameters: CollectionBulkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BatchResult>> {
        if (requestParameters.bulkRequestBody === null || requestParameters.bulkRequestBody === undefined) {
            throw new runtime.RequiredError('bulkRequestBody','Required parameter requestParameters.bulkRequestBody was null or undefined when calling collectionBulk.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/collection/bulk`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BulkRequestBodyToJSON(requestParameters.bulkRequestBody),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BatchResultFromJSON(jsonValue));
    }

    /**
     * Bulk operations (retry, cancel...).
     * bulk collection
     */
    async collectionBulk(requestParameters: CollectionBulkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchResult> {
        const response = await this.collectionBulkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve status of current bulk operation.
     * bulk_status collection
     */
    async collectionBulkStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BulkStatusResult>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/collection/bulk`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BulkStatusResultFromJSON(jsonValue));
    }

    /**
     * Retrieve status of current bulk operation.
     * bulk_status collection
     */
    async collectionBulkStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BulkStatusResult> {
        const response = await this.collectionBulkStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * Cancel collection processing by ID
     * cancel collection
     */
    async collectionCancelRaw(requestParameters: CollectionCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling collectionCancel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/collection/{id}/cancel`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Cancel collection processing by ID
     * cancel collection
     */
    async collectionCancel(requestParameters: CollectionCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.collectionCancelRaw(requestParameters, initOverrides);
    }

    /**
     * Make decision for a pending collection by ID
     * decide collection
     */
    async collectionDecideRaw(requestParameters: CollectionDecideOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling collectionDecide.');
        }

        if (requestParameters.collectionDecideRequest === null || requestParameters.collectionDecideRequest === undefined) {
            throw new runtime.RequiredError('collectionDecideRequest','Required parameter requestParameters.collectionDecideRequest was null or undefined when calling collectionDecide.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/collection/{id}/decision`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CollectionDecideRequestToJSON(requestParameters.collectionDecideRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Make decision for a pending collection by ID
     * decide collection
     */
    async collectionDecide(requestParameters: CollectionDecideOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.collectionDecideRaw(requestParameters, initOverrides);
    }

    /**
     * Delete collection by ID
     * delete collection
     */
    async collectionDeleteRaw(requestParameters: CollectionDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling collectionDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/collection/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete collection by ID
     * delete collection
     */
    async collectionDelete(requestParameters: CollectionDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.collectionDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Download collection by ID
     * download collection
     */
    async collectionDownloadRaw(requestParameters: CollectionDownloadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling collectionDownload.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/collection/{id}/download`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Download collection by ID
     * download collection
     */
    async collectionDownload(requestParameters: CollectionDownloadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.collectionDownloadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all stored collections
     * list collection
     */
    async collectionListRaw(requestParameters: CollectionListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListResponseBody>> {
        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.originalId !== undefined) {
            queryParameters['original_id'] = requestParameters.originalId;
        }

        if (requestParameters.transferId !== undefined) {
            queryParameters['transfer_id'] = requestParameters.transferId;
        }

        if (requestParameters.aipId !== undefined) {
            queryParameters['aip_id'] = requestParameters.aipId;
        }

        if (requestParameters.pipelineId !== undefined) {
            queryParameters['pipeline_id'] = requestParameters.pipelineId;
        }

        if (requestParameters.earliestCreatedTime !== undefined) {
            queryParameters['earliest_created_time'] = (requestParameters.earliestCreatedTime as any).toISOString();
        }

        if (requestParameters.latestCreatedTime !== undefined) {
            queryParameters['latest_created_time'] = (requestParameters.latestCreatedTime as any).toISOString();
        }

        if (requestParameters.status !== undefined) {
            queryParameters['status'] = requestParameters.status;
        }

        if (requestParameters.cursor !== undefined) {
            queryParameters['cursor'] = requestParameters.cursor;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/collection`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListResponseBodyFromJSON(jsonValue));
    }

    /**
     * List all stored collections
     * list collection
     */
    async collectionList(requestParameters: CollectionListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListResponseBody> {
        const response = await this.collectionListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * monitor collection
     */
    async collectionMonitorRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/collection/monitor`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * monitor collection
     */
    async collectionMonitor(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.collectionMonitorRaw(initOverrides);
    }

    /**
     * Retry collection processing by ID
     * retry collection
     */
    async collectionRetryRaw(requestParameters: CollectionRetryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling collectionRetry.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/collection/{id}/retry`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retry collection processing by ID
     * retry collection
     */
    async collectionRetry(requestParameters: CollectionRetryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.collectionRetryRaw(requestParameters, initOverrides);
    }

    /**
     * Show collection by ID
     * show collection
     */
    async collectionShowRaw(requestParameters: CollectionShowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnduroStoredCollection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling collectionShow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/collection/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnduroStoredCollectionFromJSON(jsonValue));
    }

    /**
     * Show collection by ID
     * show collection
     */
    async collectionShow(requestParameters: CollectionShowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnduroStoredCollection> {
        const response = await this.collectionShowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve workflow status by ID
     * workflow collection
     */
    async collectionWorkflowRaw(requestParameters: CollectionWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnduroCollectionWorkflowStatus>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling collectionWorkflow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/collection/{id}/workflow`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnduroCollectionWorkflowStatusFromJSON(jsonValue));
    }

    /**
     * Retrieve workflow status by ID
     * workflow collection
     */
    async collectionWorkflow(requestParameters: CollectionWorkflowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnduroCollectionWorkflowStatus> {
        const response = await this.collectionWorkflowRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CollectionListStatusEnum = {
    New: 'new',
    InProgress: 'in progress',
    Done: 'done',
    Error: 'error',
    Unknown: 'unknown',
    Queued: 'queued',
    Pending: 'pending',
    Abandoned: 'abandoned'
} as const;
export type CollectionListStatusEnum = typeof CollectionListStatusEnum[keyof typeof CollectionListStatusEnum];
