// Code generated by goa v3.11.3, DO NOT EDIT.
//
// collection HTTP client types
//
// Command:
// $ goa gen github.com/artefactual-labs/enduro/internal/api/design -o
// internal/api

package client

import (
	collection "github.com/artefactual-labs/enduro/internal/api/gen/collection"
	collectionviews "github.com/artefactual-labs/enduro/internal/api/gen/collection/views"
	goa "goa.design/goa/v3/pkg"
)

// BulkRequestBody is the type of the "collection" service "bulk" endpoint HTTP
// request body.
type BulkRequestBody struct {
	Operation string `form:"operation" json:"operation" xml:"operation"`
	Status    string `form:"status" json:"status" xml:"status"`
	Size      uint   `form:"size" json:"size" xml:"size"`
}

// MonitorResponseBody is the type of the "collection" service "monitor"
// endpoint HTTP response body.
type MonitorResponseBody struct {
	// Identifier of collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Type of the event
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Collection
	Item *EnduroStoredCollectionResponseBody `form:"item,omitempty" json:"item,omitempty" xml:"item,omitempty"`
}

// ListResponseBody is the type of the "collection" service "list" endpoint
// HTTP response body.
type ListResponseBody struct {
	Items      EnduroStoredCollectionCollectionResponseBody `form:"items,omitempty" json:"items,omitempty" xml:"items,omitempty"`
	NextCursor *string                                      `form:"next_cursor,omitempty" json:"next_cursor,omitempty" xml:"next_cursor,omitempty"`
}

// ShowResponseBody is the type of the "collection" service "show" endpoint
// HTTP response body.
type ShowResponseBody struct {
	// Identifier of collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Name of the collection
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Status of the collection
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Identifier of processing workflow
	WorkflowID *string `form:"workflow_id,omitempty" json:"workflow_id,omitempty" xml:"workflow_id,omitempty"`
	// Identifier of latest processing workflow run
	RunID *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
	// Identifier of Archivematica transfer
	TransferID *string `form:"transfer_id,omitempty" json:"transfer_id,omitempty" xml:"transfer_id,omitempty"`
	// Identifier of Archivematica AIP
	AipID *string `form:"aip_id,omitempty" json:"aip_id,omitempty" xml:"aip_id,omitempty"`
	// Identifier provided by the client
	OriginalID *string `form:"original_id,omitempty" json:"original_id,omitempty" xml:"original_id,omitempty"`
	// Identifier of Archivematica pipeline
	PipelineID *string `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty" xml:"pipeline_id,omitempty"`
	// Creation datetime
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// Start datetime
	StartedAt *string `form:"started_at,omitempty" json:"started_at,omitempty" xml:"started_at,omitempty"`
	// Completion datetime
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
}

// WorkflowResponseBody is the type of the "collection" service "workflow"
// endpoint HTTP response body.
type WorkflowResponseBody struct {
	Status  *string                                               `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	History EnduroCollectionWorkflowHistoryCollectionResponseBody `form:"history,omitempty" json:"history,omitempty" xml:"history,omitempty"`
}

// BulkResponseBody is the type of the "collection" service "bulk" endpoint
// HTTP response body.
type BulkResponseBody struct {
	WorkflowID *string `form:"workflow_id,omitempty" json:"workflow_id,omitempty" xml:"workflow_id,omitempty"`
	RunID      *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
}

// BulkStatusResponseBody is the type of the "collection" service "bulk_status"
// endpoint HTTP response body.
type BulkStatusResponseBody struct {
	Running    *bool   `form:"running,omitempty" json:"running,omitempty" xml:"running,omitempty"`
	StartedAt  *string `form:"started_at,omitempty" json:"started_at,omitempty" xml:"started_at,omitempty"`
	ClosedAt   *string `form:"closed_at,omitempty" json:"closed_at,omitempty" xml:"closed_at,omitempty"`
	Status     *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	WorkflowID *string `form:"workflow_id,omitempty" json:"workflow_id,omitempty" xml:"workflow_id,omitempty"`
	RunID      *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
}

// ShowNotFoundResponseBody is the type of the "collection" service "show"
// endpoint HTTP response body for the "not_found" error.
type ShowNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// DeleteNotFoundResponseBody is the type of the "collection" service "delete"
// endpoint HTTP response body for the "not_found" error.
type DeleteNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// CancelNotFoundResponseBody is the type of the "collection" service "cancel"
// endpoint HTTP response body for the "not_found" error.
type CancelNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// CancelNotRunningResponseBody is the type of the "collection" service
// "cancel" endpoint HTTP response body for the "not_running" error.
type CancelNotRunningResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RetryNotFoundResponseBody is the type of the "collection" service "retry"
// endpoint HTTP response body for the "not_found" error.
type RetryNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// RetryNotRunningResponseBody is the type of the "collection" service "retry"
// endpoint HTTP response body for the "not_running" error.
type RetryNotRunningResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// WorkflowNotFoundResponseBody is the type of the "collection" service
// "workflow" endpoint HTTP response body for the "not_found" error.
type WorkflowNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// DownloadNotFoundResponseBody is the type of the "collection" service
// "download" endpoint HTTP response body for the "not_found" error.
type DownloadNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// DecideNotFoundResponseBody is the type of the "collection" service "decide"
// endpoint HTTP response body for the "not_found" error.
type DecideNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// DecideNotValidResponseBody is the type of the "collection" service "decide"
// endpoint HTTP response body for the "not_valid" error.
type DecideNotValidResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// BulkNotAvailableResponseBody is the type of the "collection" service "bulk"
// endpoint HTTP response body for the "not_available" error.
type BulkNotAvailableResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// BulkNotValidResponseBody is the type of the "collection" service "bulk"
// endpoint HTTP response body for the "not_valid" error.
type BulkNotValidResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// EnduroStoredCollectionResponseBody is used to define fields on response body
// types.
type EnduroStoredCollectionResponseBody struct {
	// Identifier of collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Name of the collection
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Status of the collection
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Identifier of processing workflow
	WorkflowID *string `form:"workflow_id,omitempty" json:"workflow_id,omitempty" xml:"workflow_id,omitempty"`
	// Identifier of latest processing workflow run
	RunID *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
	// Identifier of Archivematica transfer
	TransferID *string `form:"transfer_id,omitempty" json:"transfer_id,omitempty" xml:"transfer_id,omitempty"`
	// Identifier of Archivematica AIP
	AipID *string `form:"aip_id,omitempty" json:"aip_id,omitempty" xml:"aip_id,omitempty"`
	// Identifier provided by the client
	OriginalID *string `form:"original_id,omitempty" json:"original_id,omitempty" xml:"original_id,omitempty"`
	// Identifier of Archivematica pipeline
	PipelineID *string `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty" xml:"pipeline_id,omitempty"`
	// Creation datetime
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// Start datetime
	StartedAt *string `form:"started_at,omitempty" json:"started_at,omitempty" xml:"started_at,omitempty"`
	// Completion datetime
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
}

// EnduroStoredCollectionCollectionResponseBody is used to define fields on
// response body types.
type EnduroStoredCollectionCollectionResponseBody []*EnduroStoredCollectionResponseBody

// EnduroCollectionWorkflowHistoryCollectionResponseBody is used to define
// fields on response body types.
type EnduroCollectionWorkflowHistoryCollectionResponseBody []*EnduroCollectionWorkflowHistoryResponseBody

// EnduroCollectionWorkflowHistoryResponseBody is used to define fields on
// response body types.
type EnduroCollectionWorkflowHistoryResponseBody struct {
	// Identifier of collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Type of the event
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Contents of the event
	Details any `form:"details,omitempty" json:"details,omitempty" xml:"details,omitempty"`
}

// NewBulkRequestBody builds the HTTP request body from the payload of the
// "bulk" endpoint of the "collection" service.
func NewBulkRequestBody(p *collection.BulkPayload) *BulkRequestBody {
	body := &BulkRequestBody{
		Operation: p.Operation,
		Status:    p.Status,
		Size:      p.Size,
	}
	{
		var zero uint
		if body.Size == zero {
			body.Size = 100
		}
	}
	return body
}

// NewMonitorEnduroMonitorUpdateOK builds a "collection" service "monitor"
// endpoint result from a HTTP "OK" response.
func NewMonitorEnduroMonitorUpdateOK(body *MonitorResponseBody) *collectionviews.EnduroMonitorUpdateView {
	v := &collectionviews.EnduroMonitorUpdateView{
		ID:   body.ID,
		Type: body.Type,
	}
	if body.Item != nil {
		v.Item = unmarshalEnduroStoredCollectionResponseBodyToCollectionviewsEnduroStoredCollectionView(body.Item)
	}

	return v
}

// NewListResultOK builds a "collection" service "list" endpoint result from a
// HTTP "OK" response.
func NewListResultOK(body *ListResponseBody) *collection.ListResult {
	v := &collection.ListResult{
		NextCursor: body.NextCursor,
	}
	v.Items = make([]*collection.EnduroStoredCollection, len(body.Items))
	for i, val := range body.Items {
		v.Items[i] = unmarshalEnduroStoredCollectionResponseBodyToCollectionEnduroStoredCollection(val)
	}

	return v
}

// NewShowEnduroStoredCollectionOK builds a "collection" service "show"
// endpoint result from a HTTP "OK" response.
func NewShowEnduroStoredCollectionOK(body *ShowResponseBody) *collectionviews.EnduroStoredCollectionView {
	v := &collectionviews.EnduroStoredCollectionView{
		ID:          body.ID,
		Name:        body.Name,
		Status:      body.Status,
		WorkflowID:  body.WorkflowID,
		RunID:       body.RunID,
		TransferID:  body.TransferID,
		AipID:       body.AipID,
		OriginalID:  body.OriginalID,
		PipelineID:  body.PipelineID,
		CreatedAt:   body.CreatedAt,
		StartedAt:   body.StartedAt,
		CompletedAt: body.CompletedAt,
	}

	return v
}

// NewShowNotFound builds a collection service show endpoint not_found error.
func NewShowNotFound(body *ShowNotFoundResponseBody) *collection.CollectionNotfound {
	v := &collection.CollectionNotfound{
		Message: *body.Message,
		ID:      *body.ID,
	}

	return v
}

// NewDeleteNotFound builds a collection service delete endpoint not_found
// error.
func NewDeleteNotFound(body *DeleteNotFoundResponseBody) *collection.CollectionNotfound {
	v := &collection.CollectionNotfound{
		Message: *body.Message,
		ID:      *body.ID,
	}

	return v
}

// NewCancelNotFound builds a collection service cancel endpoint not_found
// error.
func NewCancelNotFound(body *CancelNotFoundResponseBody) *collection.CollectionNotfound {
	v := &collection.CollectionNotfound{
		Message: *body.Message,
		ID:      *body.ID,
	}

	return v
}

// NewCancelNotRunning builds a collection service cancel endpoint not_running
// error.
func NewCancelNotRunning(body *CancelNotRunningResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRetryNotFound builds a collection service retry endpoint not_found error.
func NewRetryNotFound(body *RetryNotFoundResponseBody) *collection.CollectionNotfound {
	v := &collection.CollectionNotfound{
		Message: *body.Message,
		ID:      *body.ID,
	}

	return v
}

// NewRetryNotRunning builds a collection service retry endpoint not_running
// error.
func NewRetryNotRunning(body *RetryNotRunningResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewWorkflowEnduroCollectionWorkflowStatusOK builds a "collection" service
// "workflow" endpoint result from a HTTP "OK" response.
func NewWorkflowEnduroCollectionWorkflowStatusOK(body *WorkflowResponseBody) *collectionviews.EnduroCollectionWorkflowStatusView {
	v := &collectionviews.EnduroCollectionWorkflowStatusView{
		Status: body.Status,
	}
	if body.History != nil {
		v.History = make([]*collectionviews.EnduroCollectionWorkflowHistoryView, len(body.History))
		for i, val := range body.History {
			v.History[i] = unmarshalEnduroCollectionWorkflowHistoryResponseBodyToCollectionviewsEnduroCollectionWorkflowHistoryView(val)
		}
	}

	return v
}

// NewWorkflowNotFound builds a collection service workflow endpoint not_found
// error.
func NewWorkflowNotFound(body *WorkflowNotFoundResponseBody) *collection.CollectionNotfound {
	v := &collection.CollectionNotfound{
		Message: *body.Message,
		ID:      *body.ID,
	}

	return v
}

// NewDownloadResultOK builds a "collection" service "download" endpoint result
// from a HTTP "OK" response.
func NewDownloadResultOK(contentType string, contentLength int64, contentDisposition string) *collection.DownloadResult {
	v := &collection.DownloadResult{}
	v.ContentType = contentType
	v.ContentLength = contentLength
	v.ContentDisposition = contentDisposition

	return v
}

// NewDownloadNotFound builds a collection service download endpoint not_found
// error.
func NewDownloadNotFound(body *DownloadNotFoundResponseBody) *collection.CollectionNotfound {
	v := &collection.CollectionNotfound{
		Message: *body.Message,
		ID:      *body.ID,
	}

	return v
}

// NewDecideNotFound builds a collection service decide endpoint not_found
// error.
func NewDecideNotFound(body *DecideNotFoundResponseBody) *collection.CollectionNotfound {
	v := &collection.CollectionNotfound{
		Message: *body.Message,
		ID:      *body.ID,
	}

	return v
}

// NewDecideNotValid builds a collection service decide endpoint not_valid
// error.
func NewDecideNotValid(body *DecideNotValidResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewBulkResultAccepted builds a "collection" service "bulk" endpoint result
// from a HTTP "Accepted" response.
func NewBulkResultAccepted(body *BulkResponseBody) *collection.BulkResult {
	v := &collection.BulkResult{
		WorkflowID: *body.WorkflowID,
		RunID:      *body.RunID,
	}

	return v
}

// NewBulkNotAvailable builds a collection service bulk endpoint not_available
// error.
func NewBulkNotAvailable(body *BulkNotAvailableResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewBulkNotValid builds a collection service bulk endpoint not_valid error.
func NewBulkNotValid(body *BulkNotValidResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewBulkStatusResultOK builds a "collection" service "bulk_status" endpoint
// result from a HTTP "OK" response.
func NewBulkStatusResultOK(body *BulkStatusResponseBody) *collection.BulkStatusResult {
	v := &collection.BulkStatusResult{
		Running:    *body.Running,
		StartedAt:  body.StartedAt,
		ClosedAt:   body.ClosedAt,
		Status:     body.Status,
		WorkflowID: body.WorkflowID,
		RunID:      body.RunID,
	}

	return v
}

// ValidateListResponseBody runs the validations defined on ListResponseBody
func ValidateListResponseBody(body *ListResponseBody) (err error) {
	if body.Items == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("items", "body"))
	}
	if body.Items != nil {
		if err2 := ValidateEnduroStoredCollectionCollectionResponseBody(body.Items); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateBulkResponseBody runs the validations defined on BulkResponseBody
func ValidateBulkResponseBody(body *BulkResponseBody) (err error) {
	if body.WorkflowID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("workflow_id", "body"))
	}
	if body.RunID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("run_id", "body"))
	}
	return
}

// ValidateBulkStatusResponseBody runs the validations defined on
// bulk_status_response_body
func ValidateBulkStatusResponseBody(body *BulkStatusResponseBody) (err error) {
	if body.Running == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("running", "body"))
	}
	if body.StartedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.started_at", *body.StartedAt, goa.FormatDateTime))
	}
	if body.ClosedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.closed_at", *body.ClosedAt, goa.FormatDateTime))
	}
	return
}

// ValidateShowNotFoundResponseBody runs the validations defined on
// show_not_found_response_body
func ValidateShowNotFoundResponseBody(body *ShowNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateDeleteNotFoundResponseBody runs the validations defined on
// delete_not_found_response_body
func ValidateDeleteNotFoundResponseBody(body *DeleteNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateCancelNotFoundResponseBody runs the validations defined on
// cancel_not_found_response_body
func ValidateCancelNotFoundResponseBody(body *CancelNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateCancelNotRunningResponseBody runs the validations defined on
// cancel_not_running_response_body
func ValidateCancelNotRunningResponseBody(body *CancelNotRunningResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRetryNotFoundResponseBody runs the validations defined on
// retry_not_found_response_body
func ValidateRetryNotFoundResponseBody(body *RetryNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateRetryNotRunningResponseBody runs the validations defined on
// retry_not_running_response_body
func ValidateRetryNotRunningResponseBody(body *RetryNotRunningResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateWorkflowNotFoundResponseBody runs the validations defined on
// workflow_not_found_response_body
func ValidateWorkflowNotFoundResponseBody(body *WorkflowNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateDownloadNotFoundResponseBody runs the validations defined on
// download_not_found_response_body
func ValidateDownloadNotFoundResponseBody(body *DownloadNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateDecideNotFoundResponseBody runs the validations defined on
// decide_not_found_response_body
func ValidateDecideNotFoundResponseBody(body *DecideNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateDecideNotValidResponseBody runs the validations defined on
// decide_not_valid_response_body
func ValidateDecideNotValidResponseBody(body *DecideNotValidResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateBulkNotAvailableResponseBody runs the validations defined on
// bulk_not_available_response_body
func ValidateBulkNotAvailableResponseBody(body *BulkNotAvailableResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateBulkNotValidResponseBody runs the validations defined on
// bulk_not_valid_response_body
func ValidateBulkNotValidResponseBody(body *BulkNotValidResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateEnduroStoredCollectionResponseBody runs the validations defined on
// EnduroStored-CollectionResponseBody
func ValidateEnduroStoredCollectionResponseBody(body *EnduroStoredCollectionResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "new" || *body.Status == "in progress" || *body.Status == "done" || *body.Status == "error" || *body.Status == "unknown" || *body.Status == "queued" || *body.Status == "pending" || *body.Status == "abandoned") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"new", "in progress", "done", "error", "unknown", "queued", "pending", "abandoned"}))
		}
	}
	if body.WorkflowID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.workflow_id", *body.WorkflowID, goa.FormatUUID))
	}
	if body.RunID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.run_id", *body.RunID, goa.FormatUUID))
	}
	if body.TransferID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.transfer_id", *body.TransferID, goa.FormatUUID))
	}
	if body.AipID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.aip_id", *body.AipID, goa.FormatUUID))
	}
	if body.PipelineID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.pipeline_id", *body.PipelineID, goa.FormatUUID))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.StartedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.started_at", *body.StartedAt, goa.FormatDateTime))
	}
	if body.CompletedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.completed_at", *body.CompletedAt, goa.FormatDateTime))
	}
	return
}

// ValidateEnduroStoredCollectionCollectionResponseBody runs the validations
// defined on EnduroStored-CollectionCollectionResponseBody
func ValidateEnduroStoredCollectionCollectionResponseBody(body EnduroStoredCollectionCollectionResponseBody) (err error) {
	for _, e := range body {
		if e != nil {
			if err2 := ValidateEnduroStoredCollectionResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}
