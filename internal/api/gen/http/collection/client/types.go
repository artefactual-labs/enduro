// Code generated by goa v3.0.9, DO NOT EDIT.
//
// collection HTTP client types
//
// Command:
// $ goa gen github.com/artefactual-labs/enduro/internal/api/design -o
// internal/api

package client

import (
	collection "github.com/artefactual-labs/enduro/internal/api/gen/collection"
	collectionviews "github.com/artefactual-labs/enduro/internal/api/gen/collection/views"
	goa "goa.design/goa/v3/pkg"
)

// ListResponseBody is the type of the "collection" service "list" endpoint
// HTTP response body.
type ListResponseBody struct {
	Items      EnduroStoredCollectionCollectionResponseBody `form:"items,omitempty" json:"items,omitempty" xml:"items,omitempty"`
	NextCursor *string                                      `form:"next_cursor,omitempty" json:"next_cursor,omitempty" xml:"next_cursor,omitempty"`
}

// ShowResponseBody is the type of the "collection" service "show" endpoint
// HTTP response body.
type ShowResponseBody struct {
	// Identifier of collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Name of the collection
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Status of the collection
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Identifier of processing workflow
	WorkflowID *string `form:"workflow_id,omitempty" json:"workflow_id,omitempty" xml:"workflow_id,omitempty"`
	// Identifier of latest processing workflow run
	RunID *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
	// Identifier of Archivematica transfer
	TransferID *string `form:"transfer_id,omitempty" json:"transfer_id,omitempty" xml:"transfer_id,omitempty"`
	// Identifier of Archivematica AIP
	AipID *string `form:"aip_id,omitempty" json:"aip_id,omitempty" xml:"aip_id,omitempty"`
	// Identifier provided by the client
	OriginalID *string `form:"original_id,omitempty" json:"original_id,omitempty" xml:"original_id,omitempty"`
	// Identifier of Archivematica pipeline
	PipelineID *string `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty" xml:"pipeline_id,omitempty"`
	// Creation datetime
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// Start datetime
	StartedAt *string `form:"started_at,omitempty" json:"started_at,omitempty" xml:"started_at,omitempty"`
	// Completion datetime
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
}

// WorkflowResponseBody is the type of the "collection" service "workflow"
// endpoint HTTP response body.
type WorkflowResponseBody struct {
	Status  *string                                               `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	History EnduroCollectionWorkflowHistoryCollectionResponseBody `form:"history,omitempty" json:"history,omitempty" xml:"history,omitempty"`
}

// ShowNotFoundResponseBody is the type of the "collection" service "show"
// endpoint HTTP response body for the "not_found" error.
type ShowNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// DeleteNotFoundResponseBody is the type of the "collection" service "delete"
// endpoint HTTP response body for the "not_found" error.
type DeleteNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// CancelNotFoundResponseBody is the type of the "collection" service "cancel"
// endpoint HTTP response body for the "not_found" error.
type CancelNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// CancelNotRunningResponseBody is the type of the "collection" service
// "cancel" endpoint HTTP response body for the "not_running" error.
type CancelNotRunningResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RetryNotFoundResponseBody is the type of the "collection" service "retry"
// endpoint HTTP response body for the "not_found" error.
type RetryNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// RetryNotRunningResponseBody is the type of the "collection" service "retry"
// endpoint HTTP response body for the "not_running" error.
type RetryNotRunningResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// WorkflowNotFoundResponseBody is the type of the "collection" service
// "workflow" endpoint HTTP response body for the "not_found" error.
type WorkflowNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// DownloadNotFoundResponseBody is the type of the "collection" service
// "download" endpoint HTTP response body for the "not_found" error.
type DownloadNotFoundResponseBody struct {
	// Message of error
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Identifier of missing collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
}

// EnduroStoredCollectionCollectionResponseBody is used to define fields on
// response body types.
type EnduroStoredCollectionCollectionResponseBody []*EnduroStoredCollectionResponseBody

// EnduroStoredCollectionResponseBody is used to define fields on response body
// types.
type EnduroStoredCollectionResponseBody struct {
	// Identifier of collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Name of the collection
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Status of the collection
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Identifier of processing workflow
	WorkflowID *string `form:"workflow_id,omitempty" json:"workflow_id,omitempty" xml:"workflow_id,omitempty"`
	// Identifier of latest processing workflow run
	RunID *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
	// Identifier of Archivematica transfer
	TransferID *string `form:"transfer_id,omitempty" json:"transfer_id,omitempty" xml:"transfer_id,omitempty"`
	// Identifier of Archivematica AIP
	AipID *string `form:"aip_id,omitempty" json:"aip_id,omitempty" xml:"aip_id,omitempty"`
	// Identifier provided by the client
	OriginalID *string `form:"original_id,omitempty" json:"original_id,omitempty" xml:"original_id,omitempty"`
	// Identifier of Archivematica pipeline
	PipelineID *string `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty" xml:"pipeline_id,omitempty"`
	// Creation datetime
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// Start datetime
	StartedAt *string `form:"started_at,omitempty" json:"started_at,omitempty" xml:"started_at,omitempty"`
	// Completion datetime
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
}

// EnduroCollectionWorkflowHistoryCollectionResponseBody is used to define
// fields on response body types.
type EnduroCollectionWorkflowHistoryCollectionResponseBody []*EnduroCollectionWorkflowHistoryResponseBody

// EnduroCollectionWorkflowHistoryResponseBody is used to define fields on
// response body types.
type EnduroCollectionWorkflowHistoryResponseBody struct {
	// Identifier of collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Type of the event
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Contents of the event
	Details interface{} `form:"details,omitempty" json:"details,omitempty" xml:"details,omitempty"`
}

// NewListResultOK builds a "collection" service "list" endpoint result from a
// HTTP "OK" response.
func NewListResultOK(body *ListResponseBody) *collection.ListResult {
	v := &collection.ListResult{
		NextCursor: body.NextCursor,
	}
	v.Items = make([]*collection.EnduroStoredCollection, len(body.Items))
	for i, val := range body.Items {
		v.Items[i] = unmarshalEnduroStoredCollectionResponseBodyToCollectionEnduroStoredCollection(val)
	}
	return v
}

// NewShowEnduroStoredCollectionOK builds a "collection" service "show"
// endpoint result from a HTTP "OK" response.
func NewShowEnduroStoredCollectionOK(body *ShowResponseBody) *collectionviews.EnduroStoredCollectionView {
	v := &collectionviews.EnduroStoredCollectionView{
		ID:          body.ID,
		Name:        body.Name,
		Status:      body.Status,
		WorkflowID:  body.WorkflowID,
		RunID:       body.RunID,
		TransferID:  body.TransferID,
		AipID:       body.AipID,
		OriginalID:  body.OriginalID,
		PipelineID:  body.PipelineID,
		CreatedAt:   body.CreatedAt,
		StartedAt:   body.StartedAt,
		CompletedAt: body.CompletedAt,
	}
	return v
}

// NewShowNotFound builds a collection service show endpoint not_found error.
func NewShowNotFound(body *ShowNotFoundResponseBody) *collection.NotFound {
	v := &collection.NotFound{
		Message: *body.Message,
		ID:      *body.ID,
	}
	return v
}

// NewDeleteNotFound builds a collection service delete endpoint not_found
// error.
func NewDeleteNotFound(body *DeleteNotFoundResponseBody) *collection.NotFound {
	v := &collection.NotFound{
		Message: *body.Message,
		ID:      *body.ID,
	}
	return v
}

// NewCancelNotFound builds a collection service cancel endpoint not_found
// error.
func NewCancelNotFound(body *CancelNotFoundResponseBody) *collection.NotFound {
	v := &collection.NotFound{
		Message: *body.Message,
		ID:      *body.ID,
	}
	return v
}

// NewCancelNotRunning builds a collection service cancel endpoint not_running
// error.
func NewCancelNotRunning(body *CancelNotRunningResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}
	return v
}

// NewRetryNotFound builds a collection service retry endpoint not_found error.
func NewRetryNotFound(body *RetryNotFoundResponseBody) *collection.NotFound {
	v := &collection.NotFound{
		Message: *body.Message,
		ID:      *body.ID,
	}
	return v
}

// NewRetryNotRunning builds a collection service retry endpoint not_running
// error.
func NewRetryNotRunning(body *RetryNotRunningResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}
	return v
}

// NewWorkflowEnduroCollectionWorkflowStatusOK builds a "collection" service
// "workflow" endpoint result from a HTTP "OK" response.
func NewWorkflowEnduroCollectionWorkflowStatusOK(body *WorkflowResponseBody) *collectionviews.EnduroCollectionWorkflowStatusView {
	v := &collectionviews.EnduroCollectionWorkflowStatusView{
		Status: body.Status,
	}
	if body.History != nil {
		v.History = make([]*collectionviews.EnduroCollectionWorkflowHistoryView, len(body.History))
		for i, val := range body.History {
			v.History[i] = unmarshalEnduroCollectionWorkflowHistoryResponseBodyToCollectionviewsEnduroCollectionWorkflowHistoryView(val)
		}
	}
	return v
}

// NewWorkflowNotFound builds a collection service workflow endpoint not_found
// error.
func NewWorkflowNotFound(body *WorkflowNotFoundResponseBody) *collection.NotFound {
	v := &collection.NotFound{
		Message: *body.Message,
		ID:      *body.ID,
	}
	return v
}

// NewDownloadNotFound builds a collection service download endpoint not_found
// error.
func NewDownloadNotFound(body *DownloadNotFoundResponseBody) *collection.NotFound {
	v := &collection.NotFound{
		Message: *body.Message,
		ID:      *body.ID,
	}
	return v
}

// ValidateListResponseBody runs the validations defined on ListResponseBody
func ValidateListResponseBody(body *ListResponseBody) (err error) {
	if body.Items == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("items", "body"))
	}
	for _, e := range body.Items {
		if e != nil {
			if err2 := ValidateEnduroStoredCollectionResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateShowNotFoundResponseBody runs the validations defined on
// show_not_found_response_body
func ValidateShowNotFoundResponseBody(body *ShowNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateDeleteNotFoundResponseBody runs the validations defined on
// delete_not_found_response_body
func ValidateDeleteNotFoundResponseBody(body *DeleteNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateCancelNotFoundResponseBody runs the validations defined on
// cancel_not_found_response_body
func ValidateCancelNotFoundResponseBody(body *CancelNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateCancelNotRunningResponseBody runs the validations defined on
// cancel_not_running_response_body
func ValidateCancelNotRunningResponseBody(body *CancelNotRunningResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRetryNotFoundResponseBody runs the validations defined on
// retry_not_found_response_body
func ValidateRetryNotFoundResponseBody(body *RetryNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateRetryNotRunningResponseBody runs the validations defined on
// retry_not_running_response_body
func ValidateRetryNotRunningResponseBody(body *RetryNotRunningResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateWorkflowNotFoundResponseBody runs the validations defined on
// workflow_not_found_response_body
func ValidateWorkflowNotFoundResponseBody(body *WorkflowNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateDownloadNotFoundResponseBody runs the validations defined on
// download_not_found_response_body
func ValidateDownloadNotFoundResponseBody(body *DownloadNotFoundResponseBody) (err error) {
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	return
}

// ValidateEnduroStoredCollectionCollectionResponseBody runs the validations
// defined on EnduroStored-CollectionCollectionResponseBody
func ValidateEnduroStoredCollectionCollectionResponseBody(body EnduroStoredCollectionCollectionResponseBody) (err error) {
	for _, e := range body {
		if e != nil {
			if err2 := ValidateEnduroStoredCollectionResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateEnduroStoredCollectionResponseBody runs the validations defined on
// EnduroStored-CollectionResponseBody
func ValidateEnduroStoredCollectionResponseBody(body *EnduroStoredCollectionResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.CreatedAt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("created_at", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "new" || *body.Status == "in progress" || *body.Status == "done" || *body.Status == "error" || *body.Status == "unknown" || *body.Status == "queued") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"new", "in progress", "done", "error", "unknown", "queued"}))
		}
	}
	if body.WorkflowID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.workflow_id", *body.WorkflowID, goa.FormatUUID))
	}
	if body.RunID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.run_id", *body.RunID, goa.FormatUUID))
	}
	if body.TransferID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.transfer_id", *body.TransferID, goa.FormatUUID))
	}
	if body.AipID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.aip_id", *body.AipID, goa.FormatUUID))
	}
	if body.PipelineID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.pipeline_id", *body.PipelineID, goa.FormatUUID))
	}
	if body.CreatedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", *body.CreatedAt, goa.FormatDateTime))
	}
	if body.StartedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.started_at", *body.StartedAt, goa.FormatDateTime))
	}
	if body.CompletedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.completed_at", *body.CompletedAt, goa.FormatDateTime))
	}
	return
}
