// Code generated by goa v3.0.9, DO NOT EDIT.
//
// collection HTTP server types
//
// Command:
// $ goa gen github.com/artefactual-labs/enduro/internal/api/design -o
// internal/api

package server

import (
	collection "github.com/artefactual-labs/enduro/internal/api/gen/collection"
	collectionviews "github.com/artefactual-labs/enduro/internal/api/gen/collection/views"
	goa "goa.design/goa/v3/pkg"
)

// ListResponseBody is the type of the "collection" service "list" endpoint
// HTTP response body.
type ListResponseBody struct {
	Items      EnduroStoredCollectionCollectionResponseBody `form:"items" json:"items" xml:"items"`
	NextCursor *string                                      `form:"next_cursor,omitempty" json:"next_cursor,omitempty" xml:"next_cursor,omitempty"`
}

// ShowResponseBody is the type of the "collection" service "show" endpoint
// HTTP response body.
type ShowResponseBody struct {
	// Identifier of collection
	ID uint `form:"id" json:"id" xml:"id"`
	// Name of the collection
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Status of the collection
	Status string `form:"status" json:"status" xml:"status"`
	// Identifier of processing workflow
	WorkflowID *string `form:"workflow_id,omitempty" json:"workflow_id,omitempty" xml:"workflow_id,omitempty"`
	// Identifier of latest processing workflow run
	RunID *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
	// Identifier of Archivematica transfer
	TransferID *string `form:"transfer_id,omitempty" json:"transfer_id,omitempty" xml:"transfer_id,omitempty"`
	// Identifier of Archivematica AIP
	AipID *string `form:"aip_id,omitempty" json:"aip_id,omitempty" xml:"aip_id,omitempty"`
	// Identifier provided by the client
	OriginalID *string `form:"original_id,omitempty" json:"original_id,omitempty" xml:"original_id,omitempty"`
	// Identifier of Archivematica pipeline
	PipelineID *string `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty" xml:"pipeline_id,omitempty"`
	// Creation datetime
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// Start datetime
	StartedAt *string `form:"started_at,omitempty" json:"started_at,omitempty" xml:"started_at,omitempty"`
	// Completion datetime
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
}

// WorkflowResponseBody is the type of the "collection" service "workflow"
// endpoint HTTP response body.
type WorkflowResponseBody struct {
	Status  *string                                               `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	History EnduroCollectionWorkflowHistoryResponseBodyCollection `form:"history,omitempty" json:"history,omitempty" xml:"history,omitempty"`
}

// ShowNotFoundResponseBody is the type of the "collection" service "show"
// endpoint HTTP response body for the "not_found" error.
type ShowNotFoundResponseBody struct {
	// Message of error
	Message string `form:"message" json:"message" xml:"message"`
	// Identifier of missing collection
	ID uint `form:"id" json:"id" xml:"id"`
}

// DeleteNotFoundResponseBody is the type of the "collection" service "delete"
// endpoint HTTP response body for the "not_found" error.
type DeleteNotFoundResponseBody struct {
	// Message of error
	Message string `form:"message" json:"message" xml:"message"`
	// Identifier of missing collection
	ID uint `form:"id" json:"id" xml:"id"`
}

// CancelNotFoundResponseBody is the type of the "collection" service "cancel"
// endpoint HTTP response body for the "not_found" error.
type CancelNotFoundResponseBody struct {
	// Message of error
	Message string `form:"message" json:"message" xml:"message"`
	// Identifier of missing collection
	ID uint `form:"id" json:"id" xml:"id"`
}

// CancelNotRunningResponseBody is the type of the "collection" service
// "cancel" endpoint HTTP response body for the "not_running" error.
type CancelNotRunningResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// RetryNotFoundResponseBody is the type of the "collection" service "retry"
// endpoint HTTP response body for the "not_found" error.
type RetryNotFoundResponseBody struct {
	// Message of error
	Message string `form:"message" json:"message" xml:"message"`
	// Identifier of missing collection
	ID uint `form:"id" json:"id" xml:"id"`
}

// RetryNotRunningResponseBody is the type of the "collection" service "retry"
// endpoint HTTP response body for the "not_running" error.
type RetryNotRunningResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// WorkflowNotFoundResponseBody is the type of the "collection" service
// "workflow" endpoint HTTP response body for the "not_found" error.
type WorkflowNotFoundResponseBody struct {
	// Message of error
	Message string `form:"message" json:"message" xml:"message"`
	// Identifier of missing collection
	ID uint `form:"id" json:"id" xml:"id"`
}

// DownloadNotFoundResponseBody is the type of the "collection" service
// "download" endpoint HTTP response body for the "not_found" error.
type DownloadNotFoundResponseBody struct {
	// Message of error
	Message string `form:"message" json:"message" xml:"message"`
	// Identifier of missing collection
	ID uint `form:"id" json:"id" xml:"id"`
}

// EnduroStoredCollectionCollectionResponseBody is used to define fields on
// response body types.
type EnduroStoredCollectionCollectionResponseBody []*EnduroStoredCollectionResponseBody

// EnduroStoredCollectionResponseBody is used to define fields on response body
// types.
type EnduroStoredCollectionResponseBody struct {
	// Identifier of collection
	ID uint `form:"id" json:"id" xml:"id"`
	// Name of the collection
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Status of the collection
	Status string `form:"status" json:"status" xml:"status"`
	// Identifier of processing workflow
	WorkflowID *string `form:"workflow_id,omitempty" json:"workflow_id,omitempty" xml:"workflow_id,omitempty"`
	// Identifier of latest processing workflow run
	RunID *string `form:"run_id,omitempty" json:"run_id,omitempty" xml:"run_id,omitempty"`
	// Identifier of Archivematica transfer
	TransferID *string `form:"transfer_id,omitempty" json:"transfer_id,omitempty" xml:"transfer_id,omitempty"`
	// Identifier of Archivematica AIP
	AipID *string `form:"aip_id,omitempty" json:"aip_id,omitempty" xml:"aip_id,omitempty"`
	// Identifier provided by the client
	OriginalID *string `form:"original_id,omitempty" json:"original_id,omitempty" xml:"original_id,omitempty"`
	// Identifier of Archivematica pipeline
	PipelineID *string `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty" xml:"pipeline_id,omitempty"`
	// Creation datetime
	CreatedAt string `form:"created_at" json:"created_at" xml:"created_at"`
	// Start datetime
	StartedAt *string `form:"started_at,omitempty" json:"started_at,omitempty" xml:"started_at,omitempty"`
	// Completion datetime
	CompletedAt *string `form:"completed_at,omitempty" json:"completed_at,omitempty" xml:"completed_at,omitempty"`
}

// EnduroCollectionWorkflowHistoryResponseBodyCollection is used to define
// fields on response body types.
type EnduroCollectionWorkflowHistoryResponseBodyCollection []*EnduroCollectionWorkflowHistoryResponseBody

// EnduroCollectionWorkflowHistoryResponseBody is used to define fields on
// response body types.
type EnduroCollectionWorkflowHistoryResponseBody struct {
	// Identifier of collection
	ID *uint `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Type of the event
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Contents of the event
	Details interface{} `form:"details,omitempty" json:"details,omitempty" xml:"details,omitempty"`
}

// NewListResponseBody builds the HTTP response body from the result of the
// "list" endpoint of the "collection" service.
func NewListResponseBody(res *collection.ListResult) *ListResponseBody {
	body := &ListResponseBody{
		NextCursor: res.NextCursor,
	}
	if res.Items != nil {
		body.Items = make([]*EnduroStoredCollectionResponseBody, len(res.Items))
		for i, val := range res.Items {
			body.Items[i] = marshalCollectionEnduroStoredCollectionToEnduroStoredCollectionResponseBody(val)
		}
	}
	return body
}

// NewShowResponseBody builds the HTTP response body from the result of the
// "show" endpoint of the "collection" service.
func NewShowResponseBody(res *collectionviews.EnduroStoredCollectionView) *ShowResponseBody {
	body := &ShowResponseBody{
		ID:          *res.ID,
		Name:        res.Name,
		Status:      *res.Status,
		WorkflowID:  res.WorkflowID,
		RunID:       res.RunID,
		TransferID:  res.TransferID,
		AipID:       res.AipID,
		OriginalID:  res.OriginalID,
		PipelineID:  res.PipelineID,
		CreatedAt:   *res.CreatedAt,
		StartedAt:   res.StartedAt,
		CompletedAt: res.CompletedAt,
	}
	return body
}

// NewWorkflowResponseBody builds the HTTP response body from the result of the
// "workflow" endpoint of the "collection" service.
func NewWorkflowResponseBody(res *collectionviews.EnduroCollectionWorkflowStatusView) *WorkflowResponseBody {
	body := &WorkflowResponseBody{
		Status: res.Status,
	}
	if res.History != nil {
		body.History = make([]*EnduroCollectionWorkflowHistoryResponseBody, len(res.History))
		for i, val := range res.History {
			body.History[i] = marshalCollectionviewsEnduroCollectionWorkflowHistoryViewToEnduroCollectionWorkflowHistoryResponseBody(val)
		}
	}
	return body
}

// NewShowNotFoundResponseBody builds the HTTP response body from the result of
// the "show" endpoint of the "collection" service.
func NewShowNotFoundResponseBody(res *collection.NotFound) *ShowNotFoundResponseBody {
	body := &ShowNotFoundResponseBody{
		Message: res.Message,
		ID:      res.ID,
	}
	return body
}

// NewDeleteNotFoundResponseBody builds the HTTP response body from the result
// of the "delete" endpoint of the "collection" service.
func NewDeleteNotFoundResponseBody(res *collection.NotFound) *DeleteNotFoundResponseBody {
	body := &DeleteNotFoundResponseBody{
		Message: res.Message,
		ID:      res.ID,
	}
	return body
}

// NewCancelNotFoundResponseBody builds the HTTP response body from the result
// of the "cancel" endpoint of the "collection" service.
func NewCancelNotFoundResponseBody(res *collection.NotFound) *CancelNotFoundResponseBody {
	body := &CancelNotFoundResponseBody{
		Message: res.Message,
		ID:      res.ID,
	}
	return body
}

// NewCancelNotRunningResponseBody builds the HTTP response body from the
// result of the "cancel" endpoint of the "collection" service.
func NewCancelNotRunningResponseBody(res *goa.ServiceError) *CancelNotRunningResponseBody {
	body := &CancelNotRunningResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewRetryNotFoundResponseBody builds the HTTP response body from the result
// of the "retry" endpoint of the "collection" service.
func NewRetryNotFoundResponseBody(res *collection.NotFound) *RetryNotFoundResponseBody {
	body := &RetryNotFoundResponseBody{
		Message: res.Message,
		ID:      res.ID,
	}
	return body
}

// NewRetryNotRunningResponseBody builds the HTTP response body from the result
// of the "retry" endpoint of the "collection" service.
func NewRetryNotRunningResponseBody(res *goa.ServiceError) *RetryNotRunningResponseBody {
	body := &RetryNotRunningResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewWorkflowNotFoundResponseBody builds the HTTP response body from the
// result of the "workflow" endpoint of the "collection" service.
func NewWorkflowNotFoundResponseBody(res *collection.NotFound) *WorkflowNotFoundResponseBody {
	body := &WorkflowNotFoundResponseBody{
		Message: res.Message,
		ID:      res.ID,
	}
	return body
}

// NewDownloadNotFoundResponseBody builds the HTTP response body from the
// result of the "download" endpoint of the "collection" service.
func NewDownloadNotFoundResponseBody(res *collection.NotFound) *DownloadNotFoundResponseBody {
	body := &DownloadNotFoundResponseBody{
		Message: res.Message,
		ID:      res.ID,
	}
	return body
}

// NewListPayload builds a collection service list endpoint payload.
func NewListPayload(name *string, originalID *string, transferID *string, aipID *string, pipelineID *string, earliestCreatedTime *string, latestCreatedTime *string, status *string, cursor *string) *collection.ListPayload {
	return &collection.ListPayload{
		Name:                name,
		OriginalID:          originalID,
		TransferID:          transferID,
		AipID:               aipID,
		PipelineID:          pipelineID,
		EarliestCreatedTime: earliestCreatedTime,
		LatestCreatedTime:   latestCreatedTime,
		Status:              status,
		Cursor:              cursor,
	}
}

// NewShowPayload builds a collection service show endpoint payload.
func NewShowPayload(id uint) *collection.ShowPayload {
	return &collection.ShowPayload{
		ID: id,
	}
}

// NewDeletePayload builds a collection service delete endpoint payload.
func NewDeletePayload(id uint) *collection.DeletePayload {
	return &collection.DeletePayload{
		ID: id,
	}
}

// NewCancelPayload builds a collection service cancel endpoint payload.
func NewCancelPayload(id uint) *collection.CancelPayload {
	return &collection.CancelPayload{
		ID: id,
	}
}

// NewRetryPayload builds a collection service retry endpoint payload.
func NewRetryPayload(id uint) *collection.RetryPayload {
	return &collection.RetryPayload{
		ID: id,
	}
}

// NewWorkflowPayload builds a collection service workflow endpoint payload.
func NewWorkflowPayload(id uint) *collection.WorkflowPayload {
	return &collection.WorkflowPayload{
		ID: id,
	}
}

// NewDownloadPayload builds a collection service download endpoint payload.
func NewDownloadPayload(id uint) *collection.DownloadPayload {
	return &collection.DownloadPayload{
		ID: id,
	}
}

// ValidateEnduroStoredCollectionCollectionResponseBody runs the validations
// defined on EnduroStored-CollectionCollectionResponseBody
func ValidateEnduroStoredCollectionCollectionResponseBody(body EnduroStoredCollectionCollectionResponseBody) (err error) {
	for _, e := range body {
		if e != nil {
			if err2 := ValidateEnduroStoredCollectionResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateEnduroStoredCollectionResponseBody runs the validations defined on
// EnduroStored-CollectionResponseBody
func ValidateEnduroStoredCollectionResponseBody(body *EnduroStoredCollectionResponseBody) (err error) {
	if !(body.Status == "new" || body.Status == "in progress" || body.Status == "done" || body.Status == "error" || body.Status == "unknown" || body.Status == "queued") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", body.Status, []interface{}{"new", "in progress", "done", "error", "unknown", "queued"}))
	}
	if body.WorkflowID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.workflow_id", *body.WorkflowID, goa.FormatUUID))
	}
	if body.RunID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.run_id", *body.RunID, goa.FormatUUID))
	}
	if body.TransferID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.transfer_id", *body.TransferID, goa.FormatUUID))
	}
	if body.AipID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.aip_id", *body.AipID, goa.FormatUUID))
	}
	if body.PipelineID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.pipeline_id", *body.PipelineID, goa.FormatUUID))
	}
	err = goa.MergeErrors(err, goa.ValidateFormat("body.created_at", body.CreatedAt, goa.FormatDateTime))

	if body.StartedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.started_at", *body.StartedAt, goa.FormatDateTime))
	}
	if body.CompletedAt != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.completed_at", *body.CompletedAt, goa.FormatDateTime))
	}
	return
}
